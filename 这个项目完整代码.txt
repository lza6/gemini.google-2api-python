é¡¹ç›® 'gemini-python' çš„ç»“æ„æ ‘:
ğŸ“‚ gemini-python/
    ğŸ“„ .env
    ğŸ“„ .env.example
    ğŸ“„ debug_google.py
    ğŸ“„ har_parser.py
    ğŸ“„ install_deps.py
    ğŸ“„ main.py
    ğŸ“„ requirements.txt
    ğŸ“„ start.bat
    ğŸ“„ test_debug.py
    ğŸ“‚ data/
        ğŸ“‚ projects/
        ğŸ“‚ sessions/
    ğŸ“‚ templates/
        ğŸ“„ dashboard.html
================================================================================

--- æ–‡ä»¶è·¯å¾„: .env ---

# ====================================================================
# gemini-python é…ç½®æ–‡ä»¶
# ====================================================================
# --- æ ¸å¿ƒé…ç½® ---
API_MASTER_KEY=sk-my-secret-key
SERVER_PORT=8088

# --- Gemini è®¤è¯é…ç½® (å¿…é¡»è®¾ç½®) ---
# ç™»å½• gemini.google.com æŒ‰ F12 -> Application -> Cookies è·å–
GEMINI_1PSID=è¿™é‡Œå¡«__Secure-1PSIDçš„å€¼
GEMINI_1PSIDTS=è¿™é‡Œå¡«__Secure-1PSIDTSçš„å€¼

# --- ç½‘ç»œé…ç½® ---
# å›½å†…å¿…é¡»å¡«ä»£ç†ï¼Œä¾‹å¦‚ http://127.0.0.1:7890
PROXY_URL=http://127.0.0.1:7890

--- æ–‡ä»¶è·¯å¾„: .env.example ---

# ====================================================================
# gemini-python é…ç½®æ–‡ä»¶
# ====================================================================
# --- æ ¸å¿ƒé…ç½® ---
API_MASTER_KEY=sk-my-secret-key
SERVER_PORT=8088

# --- Gemini è®¤è¯é…ç½® (å¿…é¡»è®¾ç½®) ---
# ç™»å½• gemini.google.com æŒ‰ F12 -> Application -> Cookies è·å–
GEMINI_1PSID=è¿™é‡Œå¡«__Secure-1PSIDçš„å€¼
GEMINI_1PSIDTS=è¿™é‡Œå¡«__Secure-1PSIDTSçš„å€¼

# --- ç½‘ç»œé…ç½® ---
# å›½å†…å¿…é¡»å¡«ä»£ç†ï¼Œä¾‹å¦‚ http://127.0.0.1:7890
PROXY_URL=http://127.0.0.1:7890

--- æ–‡ä»¶è·¯å¾„: debug_google.py ---

import requests
import json

# ================= é…ç½®åŒº =================
# 1. å¡«å…¥ä½ çš„ä»£ç†
PROXIES = {
    "http": "http://127.0.0.1:7890",
    "https": "http://127.0.0.1:7890"
}

# 2. å¡«å…¥ä½ åˆšæ‰æå–çš„ Cookie (åªéœ€è¦è¿™ä¸¤ä¸ªæ ¸å¿ƒçš„æµ‹è¯•)
COOKIES = {
    "__Secure-1PSID": "ä½ çš„å€¼",
    "__Secure-1PSIDTS": "ä½ çš„å€¼",
    # å¦‚æœæœ‰ CC ä¹Ÿå¡«ä¸Š
    "__Secure-1PSIDCC": "ä½ çš„å€¼" 
}

# 3. ä¼ªè£…å¤´ (å’Œ main.py ä¿æŒä¸€è‡´)
HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
}
# =========================================

def diagnose():
    print("1. æ­£åœ¨æ£€æŸ¥ä»£ç† IP å½’å±...")
    try:
        ip_info = requests.get("http://ip-api.com/json", proxies=PROXIES, timeout=10).json()
        print(f"   å½“å‰ IP: {ip_info.get('query')} | åœ°åŒº: {ip_info.get('countryCode')} ({ip_info.get('country')})")
        if ip_info.get('countryCode') in ['CN', 'HK']:
            print("   âš ï¸ è­¦å‘Š: é¦™æ¸¯/ä¸­å›½èŠ‚ç‚¹ææ˜“å¯¼è‡´ Google éªŒè¯å¤±è´¥ï¼è¯·åˆ‡æ¢è‡³ US/SGã€‚")
    except Exception as e:
        print(f"   âš ï¸ ä»£ç†è¿æ¥å¤±è´¥: {e}")
        return

    print("\n2. æ­£åœ¨å°è¯•ç›´è¿ Gemini é¦–é¡µ (éªŒè¯ Cookie)...")
    try:
        # è®¿é—® Gemini App é¦–é¡µï¼Œåº“çš„ init() å°±æ˜¯åœ¨åšè¿™ä¸ª
        resp = requests.get(
            "https://gemini.google.com/app", 
            cookies=COOKIES, 
            headers=HEADERS, 
            proxies=PROXIES,
            timeout=20,
            allow_redirects=False # ç¦æ­¢è‡ªåŠ¨è·³è½¬ï¼Œæˆ‘ä»¬è¦çœ‹æ˜¯ä¸æ˜¯è¢«é‡å®šå‘äº†
        )
        
        print(f"   HTTP çŠ¶æ€ç : {resp.status_code}")
        
        if resp.status_code == 302:
            print("   âŒ å¤±è´¥: è¢«é‡å®šå‘äº† (é€šå¸¸æ˜¯è·³å›ç™»å½•é¡µ)ã€‚")
            print(f"   è·³è½¬ç›®æ ‡: {resp.headers.get('Location')}")
            print("   ğŸ‘‰ ç»“è®º: Cookie å¤±æ•ˆã€‚è¯·å°è¯•ã€åœæ­¢åŠ è½½å¤§æ³•ã€‘é‡æ–°æå–ã€‚")
            
        elif resp.status_code == 200:
            # æ£€æŸ¥å…³é”® Token æ˜¯å¦å­˜åœ¨
            if "SNlM0e" in resp.text:
                print("   âœ… æˆåŠŸ: æ‰¾åˆ°äº† 'SNlM0e' Tokenï¼ç¯å¢ƒé…ç½®æ²¡é—®é¢˜ã€‚")
                print("   ğŸ‘‰ å»ºè®®: æ—¢ç„¶è„šæœ¬èƒ½é€šï¼Œè¯·ç¡®ä¿ data.db å·²åˆ é™¤ï¼Œå¹¶é‡å¯ä¸»ç¨‹åºå†è¯•ã€‚")
            else:
                print("   â“ å­˜ç–‘: çŠ¶æ€ç  200 ä½†æ²¡æ‰¾åˆ° Tokenã€‚å¯èƒ½æ˜¯ Google è¿”å›äº†éªŒè¯ç é¡µé¢ã€‚")
                print("   é¡µé¢æ ‡é¢˜: ", resp.text.split('<title>')[1].split('</title>')[0] if '<title>' in resp.text else 'æ— æ ‡é¢˜')
                
        else:
            print(f"   âŒ å¤±è´¥: å¼‚å¸¸çŠ¶æ€ç ã€‚")
    
    except Exception as e:
        print(f"   âŒ è¯·æ±‚å‘ç”Ÿé”™è¯¯: {e}")

if __name__ == "__main__":
    diagnose()

--- æ–‡ä»¶è·¯å¾„: har_parser.py ---

import json
import re
from urllib.parse import urlparse, parse_qs, unquote
from typing import Dict, Any, Optional, Tuple, List

def extract_best_json(text: str) -> Optional[Dict]:
    """
    ä»æ··ä¹±çš„æ–‡æœ¬ä¸­æå–æœ€å¤§/æœ€å¯èƒ½çš„æœ‰æ•ˆ JSON å¯¹è±¡ã€‚
    è§£å†³äº†ç›´æ¥æ­£åˆ™åŒ¹é…åœ¨åŒ…å«å¤šä¸ªèŠ±æ‹¬å·æˆ–æ—¥å¿—å¤´æ—¶å¤±è´¥çš„é—®é¢˜ã€‚
    """
    text = text.strip().replace('\ufeff', '')
    
    # 1. å°è¯•ç›´æ¥è§£æ
    try:
        return json.loads(text)
    except:
        pass

    # 2. å°è¯•å¯»æ‰¾æœ€å¤–å±‚çš„ {}
    starts = [m.start() for m in re.finditer(r'\{', text)]
    
    if not starts:
        return None

    # ä»æœ€æ—©çš„èµ·å§‹ç‚¹å¼€å§‹ï¼Œå°è¯•å¯»æ‰¾èƒ½è§£æçš„ JSON
    for start in starts:
        # å°è¯•åŒ¹é…åˆ°å­—ç¬¦ä¸²æœ«å°¾çš„æœ€åä¸€ä¸ª }
        end_search = text.rfind('}')
        if end_search == -1 or end_search < start:
            continue
            
        candidate_str = text[start : end_search + 1]
        
        # ä¼˜åŒ–ï¼šå°è¯•å»é™¤ JSON ä¹‹å‰çš„ BOM æˆ–å…¶ä»–é JSON å­—ç¬¦
        if candidate_str.startswith(')]}\''):
            candidate_str = candidate_str[4:]
        
        try:
            data = json.loads(candidate_str)
            # ç¡®ä¿æ˜¯å­—å…¸ç±»å‹
            if isinstance(data, dict):
                return data 
        except:
            continue
            
    return None

def parse_cookies_from_header_list(headers: List[Dict]) -> Dict[str, str]:
    """ä» HAR æ ¼å¼çš„ headers åˆ—è¡¨ä¸­æå– Cookie"""
    cookie_str = ""
    for header in headers:
        # å¿½ç•¥å¤§å°å†™æŸ¥æ‰¾ 'Cookie' å¤´
        if header.get('name', '').lower() == 'cookie':
            cookie_str = header.get('value', '')
            break
    return parse_cookies_from_string(cookie_str)

def parse_cookies_from_string(cookie_string: str) -> Dict[str, str]:
    """ä» Cookie å­—ç¬¦ä¸²ä¸­æå–å…³é”® Cookieã€‚"""
    if not cookie_string:
        return {}
        
    # å¢åŠ æ›´å¤šç›¸å…³çš„ Cookie åç§°ä»¥æé«˜æˆåŠŸç‡
    target_keywords = ['PSID', 'PSIDTS', 'SID', 'APISID', 'HSID', 'SSID', 'ENID', 'AEC', 'NID', 'SIDCC']
    
    cookies = {}
    # å…ˆæ¸…ç†å­—ç¬¦ä¸²ï¼Œç§»é™¤å¯èƒ½çš„ JSON å†…å®¹
    cookie_string = cookie_string.split('"}')[0].split('"]')[0]
    
    # å¤„ç†å¯èƒ½çš„åˆ†éš”ç¬¦ï¼šåˆ†å·åå¯èƒ½è·Ÿç©ºæ ¼ï¼Œä¹Ÿå¯èƒ½æ²¡æœ‰
    parts = cookie_string.split(';')
    for pair in parts:
        if '=' in pair:
            name, value = pair.split('=', 1)
            name = name.strip()
            value = value.strip()
            
            # é¢å¤–æ¸…ç†ï¼šç§»é™¤ value ä¸­çš„å¼•å·å’Œå¤šä½™å­—ç¬¦
            value = value.strip('"\'')  # ç§»é™¤é¦–å°¾çš„å¼•å·
            # ç§»é™¤å¯èƒ½çš„ JSON ç»“æŸç¬¦
            for sep in ['"}', '"]', '}','\n', '\r', '\t']:
                if sep in value:
                    value = value.split(sep)[0]
            
            # æ£€æŸ¥æ˜¯å¦åŒ…å«ç›®æ ‡å…³é”®è¯
            if any(keyword in name for keyword in target_keywords):
                cookies[name] = value
                 
    return cookies

def parse_har_content(har_content: str) -> Tuple[bool, Optional[Dict], str]:
    """è§£æ HAR æ–‡ä»¶å†…å®¹ï¼Œå¹¶è¿”å›æ—¥å¿—ã€‚"""
    log_messages = ["-> å°è¯•ä½¿ç”¨æ ‡å‡† HAR/JSON è§£æ..."]
    
    data = extract_best_json(har_content)
    if not data:
        log_messages.append("    [å¤±è´¥] æœªæ‰¾åˆ°æœ‰æ•ˆçš„ JSON ç»“æ„ã€‚")
        return (False, None, "\n".join(log_messages))
        
    target_entry = None
    
    # é€’å½’æŸ¥æ‰¾åŒ…å«ç‰¹å®š URL çš„ request å¯¹è±¡
    def find_entry(obj):
        if isinstance(obj, dict):
            if 'url' in obj and ('/StreamGenerate' in obj['url'] or 'f.sid' in obj['url']):
                return obj
            if 'request' in obj:
                res = find_entry(obj['request'])
                if res: return res
            
            for key, value in obj.items():
                if isinstance(value, (dict, list)):
                    res = find_entry(value)
                    if res: return res
        elif isinstance(obj, list):
            for item in obj:
                res = find_entry(item)
                if res: return res
        return None

    # ä¼˜å…ˆæ£€æŸ¥æ ‡å‡†çš„ log -> entries ç»“æ„
    if isinstance(data, dict) and 'log' in data and 'entries' in data['log']:
        for entry in reversed(data['log']['entries']):
            if 'request' in entry and 'url' in entry['request']:
                if '/StreamGenerate' in entry['request']['url'] and entry['request'].get('method') == 'POST':
                    target_entry = entry['request']
                    break
    
    if not target_entry:
        target_entry = find_entry(data)

    if not target_entry:
        log_messages.append("    [å¤±è´¥] æœªæ‰¾åˆ° StreamGenerate API è¯·æ±‚è®°å½•ã€‚")
        return (False, None, "\n".join(log_messages)) 
    
    log_messages.append("    [æˆåŠŸ] æ‰¾åˆ°ç›®æ ‡ API è¯·æ±‚è®°å½•ã€‚")

    # 1. æå– f.sid
    url_parsed = urlparse(target_entry.get('url', ''))
    query_params = parse_qs(url_parsed.query)
    f_sid = query_params.get('f.sid', [None])[0]
    
    # 2. æå– at
    at_param = None
    post_data = target_entry.get('postData', {})
    if post_data.get('text'):
        text_data = post_data.get('text', '')
        if 'application/x-www-form-urlencoded' in post_data.get('mimeType', ''):
             params = parse_qs(text_data)
             at_param_encoded = params.get('at', [None])[0]
             at_param = unquote(at_param_encoded) if at_param_encoded else None
        
        if not at_param:
            at_match = re.search(r'at=([^&]+)', text_data)
            if at_match:
                 at_param = unquote(at_match.group(1))

    # 3. æå– Cookies - å¢å¼ºç‰ˆæœ¬
    extracted_cookies = {}
    
    # æ–¹æ³•1: ä» headers ä¸­æŸ¥æ‰¾ Cookie
    if 'headers' in target_entry:
        extracted_cookies = parse_cookies_from_header_list(target_entry['headers'])
        log_messages.append(f"    [è°ƒè¯•] ä» headers æå–åˆ° {len(extracted_cookies)} ä¸ª Cookie")
    
    # æ–¹æ³•2: å¦‚æœ headers æ²¡æ‰¾åˆ°ï¼Œå°è¯•ä» cookies å­—æ®µè·å–
    if not extracted_cookies and 'cookies' in target_entry and isinstance(target_entry['cookies'], list):
        temp_cookie_str = ""
        for c in target_entry['cookies']:
             temp_cookie_str += f"{c['name']}={c['value']}; "
        extracted_cookies = parse_cookies_from_string(temp_cookie_str)
        log_messages.append(f"    [è°ƒè¯•] ä» cookies å­—æ®µæå–åˆ° {len(extracted_cookies)} ä¸ª Cookie")
    
    # æ–¹æ³•3: å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œåœ¨æ•´ä¸ª HAR æ–‡ä»¶ä¸­æœç´¢ Cookie
    if not extracted_cookies:
        # é€’å½’æœç´¢æ•´ä¸ª HAR æ–‡ä»¶ä¸­çš„æ‰€æœ‰ Cookie
        def find_all_cookies(obj):
            cookies = {}
            if isinstance(obj, dict):
                # æ£€æŸ¥æ˜¯å¦æœ‰ cookie ç›¸å…³å­—æ®µ
                for key in ['cookie', 'Cookie', 'cookies']:
                    if key in obj:
                        if isinstance(obj[key], str):
                            cookies.update(parse_cookies_from_string(obj[key]))
                        elif isinstance(obj[key], list):
                            for item in obj[key]:
                                if isinstance(item, dict) and 'name' in item and 'value' in item:
                                    cookies[item['name']] = item['value']
                
                # é€’å½’æœç´¢
                for value in obj.values():
                    if isinstance(value, (dict, list)):
                        cookies.update(find_all_cookies(value))
            elif isinstance(obj, list):
                for item in obj:
                    if isinstance(item, (dict, list)):
                        cookies.update(find_all_cookies(item))
            return cookies
        
        all_cookies = find_all_cookies(data)
        # åªä¿ç•™æˆ‘ä»¬éœ€è¦çš„ Cookie
        for name in all_cookies:
            if any(keyword in name for keyword in ['PSID', 'PSIDTS', 'SID', 'APISID']):
                extracted_cookies[name] = all_cookies[name]
        
        log_messages.append(f"    [è°ƒè¯•] ä»æ•´ä¸ª HAR æ–‡ä»¶æœç´¢åˆ° {len(extracted_cookies)} ä¸ªå…³é”® Cookie")

    if not f_sid or not at_param:
        log_messages.append(f"    [å¤±è´¥] åŠ¨æ€å‚æ•°æå–ä¸å®Œæ•´ (fSid: {f_sid}, at: {at_param})ã€‚")
        return (False, None, "\n".join(log_messages)) 
    log_messages.append(f"    [æˆåŠŸ] æå–åˆ° f.sid å’Œ at åŠ¨æ€å‚æ•°ã€‚")
    log_messages.append(f"    [çŠ¶æ€] æå–åˆ° {len(extracted_cookies)} ä¸ªå…³é”® Cookieã€‚")

    if len(extracted_cookies) == 0:
        log_messages.append("    [âš ï¸ è­¦å‘Š] è¯·æ±‚å¤´ä¸­æœªå‘ç°å…³é”® Cookieï¼")
        
    return (True, {
        "cookies": extracted_cookies,
        "dynamicParams": {
            "fSid": f_sid,
            "at": at_param
        }
    }, "\n".join(log_messages))

def parse_text_segments(text_content: str) -> Tuple[bool, Optional[Dict], str]:
    """è§£æéæ ‡å‡†åˆ†æ®µæ–‡æœ¬ï¼Œå¹¶è¿”å›æ—¥å¿—ã€‚"""
    log_messages = ["-> å°è¯•ä½¿ç”¨éæ ‡å‡†åˆ†æ®µæ–‡æœ¬/æ­£åˆ™è§£æ..."]
    
    # 1. æå– URL (f.sid)
    url_match = re.search(r'(https?://[^\s]*(?:StreamGenerate|StreamGenerate\?)[^\s]*)', text_content)
    f_sid = None
    
    if url_match:
        full_url = url_match.group(1)
        log_messages.append(f"    [æˆåŠŸ] æå–åˆ° URL: {full_url[:60]}...")
        url_parsed = urlparse(full_url)
        query_params = parse_qs(url_parsed.query)
        f_sid = query_params.get('f.sid', [None])[0]
    else:
        # å¤‡ç”¨ï¼šç›´æ¥åœ¨æ–‡æœ¬ä¸­æœç´¢ f.sid
        sid_match = re.search(r'f\.sid\s*[:=]\s*([-0-9]+)', text_content)
        if sid_match:
             f_sid = sid_match.group(1)
             log_messages.append(f"    [æˆåŠŸ] ç›´æ¥æ­£åˆ™æå–åˆ° f.sid: {f_sid}")

    # 2. æå– at å‚æ•°
    at_param = None
    at_match = re.search(r'at=([^&\s]+)', text_content)
    if not at_match:
        at_match = re.search(r'at\s*[:=]\s*([^\s"]+)', text_content)
    
    if at_match:
        raw_at = at_match.group(1).strip()
        if '%' in raw_at and raw_at.startswith('A'):
            at_param = unquote(raw_at)
        else:
            at_param = raw_at
    
    # 3. æå– Cookie
    cookie_header_value = ""
    cookie_match = re.search(r'(?:Cookie|cookie):\s*([^\r\n]+)', text_content, re.IGNORECASE)
    if cookie_match:
        cookie_header_value = cookie_match.group(1).strip()
    elif 'SID=' in text_content and '__Secure-1PSID=' in text_content:
        # å¦‚æœç”¨æˆ·åªç²˜è´´äº† Cookie å­—ç¬¦ä¸²
         cookie_header_value = text_content 

    extracted_cookies = parse_cookies_from_string(cookie_header_value)

    if not f_sid or not at_param:
        log_messages.append(f"    [å¤±è´¥] åŠ¨æ€å‚æ•°æå–ä¸å®Œæ•´ (fSid found: {bool(f_sid)}, at found: {bool(at_param)})ã€‚")
        return (False, None, "\n".join(log_messages))
    
    log_messages.append(f"    [æˆåŠŸ] æå–åˆ° f.sid å’Œ at åŠ¨æ€å‚æ•°ã€‚")
    log_messages.append(f"    [çŠ¶æ€] æå–åˆ° {len(extracted_cookies)} ä¸ªå…³é”® Cookieã€‚")
    
    if len(extracted_cookies) == 0:
        log_messages.append("    [âš ï¸ è­¦å‘Š] æœªèƒ½æå–åˆ°å…³é”® Cookieã€‚")
    
    return (True, {
        "cookies": extracted_cookies,
        "dynamicParams": {
            "fSid": f_sid,
            "at": at_param
        }
    }, "\n".join(log_messages))

def parse_and_validate(raw_text: str) -> Tuple[bool, Optional[Dict], str]:
    """
    å°è¯•æ‰€æœ‰è§£ææ–¹æ³•ï¼Œè¿”å›ç»“æœå’Œè¯¦ç»†æ—¥å¿—ã€‚
    """
    
    # 1. å°è¯• HAR æ–‡ä»¶/JSON è¯·æ±‚è§£æ (æœ€ä¼˜å…ˆ)
    parsed_from_har = parse_har_content(raw_text)
    if parsed_from_har[0]:
        return (True, parsed_from_har[1], parsed_from_har[2] + "\nâœ… æå–æˆåŠŸ! (æ ¼å¼: HAR/JSON)")

    # 2. å°è¯•æ‰‹åŠ¨ç²˜è´´çš„åˆ†æ®µæ–‡æœ¬è§£æ (æ­£åˆ™å…œåº•ï¼Œå…¼å®¹ cURL/Request Headers æ ¼å¼)
    parsed_from_segments = parse_text_segments(raw_text)
    if parsed_from_segments[0]:
        return (True, parsed_from_segments[1], parsed_from_segments[2] + "\nâœ… æå–æˆåŠŸ! (æ ¼å¼: æ­£åˆ™æ–‡æœ¬)")
    
    # å…¨éƒ¨å¤±è´¥ï¼Œç»„åˆè¯¦ç»†æ—¥å¿—
    final_log = "\n--- âŒ æå–å¤±è´¥ï¼šè¯¦ç»†è§£ææ—¥å¿— ---\n" + \
                "--- 1. HAR/JSON è§£æå°è¯• --- \n" + parsed_from_har[2] + "\n" + \
                "--- 2. åˆ†æ®µæ–‡æœ¬è§£æå°è¯• --- \n" + parsed_from_segments[2] + "\n"
    
    return (False, None, final_log + "\nâŒ ç²˜è´´çš„å†…å®¹è§£æå¤±è´¥ã€‚è¯·ç¡®ä¿æ‚¨ç²˜è´´äº†åŒ…å« StreamGenerate è¯·æ±‚çš„å®Œæ•´å†…å®¹ã€‚")

--- æ–‡ä»¶è·¯å¾„: install_deps.py ---

import subprocess
import sys

def install(package):
    """å®‰è£… Python åŒ…"""
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

def main():
    print("æ­£åœ¨å®‰è£…å¿…è¦çš„ä¾èµ–...")
    
    packages = [
        "fastapi",
        "uvicorn[standard]",
        "pydantic-settings",
        "python-dotenv",
        "httpx",
        "loguru",
        "jinja2",
        "requests",
        "gemini_webapi>=1.17.3"
    ]
    
    for package in packages:
        try:
            print(f"å®‰è£… {package}...")
            install(package)
            print(f"âœ… {package} å®‰è£…æˆåŠŸ")
        except Exception as e:
            print(f"âŒ {package} å®‰è£…å¤±è´¥: {e}")
    
    print("\næ‰€æœ‰ä¾èµ–å®‰è£…å®Œæˆï¼ç°åœ¨å¯ä»¥è¿è¡Œ start.bat å¯åŠ¨æœåŠ¡å™¨äº†ã€‚")

if __name__ == "__main__":
    main()

--- æ–‡ä»¶è·¯å¾„: main.py ---

import sys
import sqlite3
import random
import time
import webbrowser
import uvicorn
import asyncio
import json
import requests
from typing import AsyncGenerator

from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse, StreamingResponse
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
from pydantic_settings import BaseSettings
from loguru import logger
from contextlib import asynccontextmanager

# å¼•å…¥ gemini_webapi é€†å‘åº“
from gemini_webapi import GeminiClient
# å¼•å…¥ HAR è§£ææ¨¡å—
from har_parser import parse_and_validate

# --- 1. é…ç½®åŠ è½½ ---
class Settings(BaseSettings):
    model_config = {
        "env_file": ".env",
        "env_file_encoding": 'utf-8',
        "extra": "ignore"
    }
    PORT: int = 8090
    PROXY_URL: str = "http://127.0.0.1:7890"  # è®°å¾—æ”¹æˆä½ çš„ä»£ç†ç«¯å£
    GEMINI_1PSID: str = "" 
    GEMINI_1PSIDTS: str = "" 

settings = Settings()

# --- 2. æ•°æ®åº“é€»è¾‘ ---
DB_FILE = "data.db"

def init_db():
    conn = sqlite3.connect(DB_FILE)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS accounts
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  name TEXT,
                  cookie_1psid TEXT,
                  cookie_1psidts TEXT,
                  cookie_1psidcc TEXT,
                  cookie_json TEXT,  
                  is_active INTEGER DEFAULT 1,
                  total_calls INTEGER DEFAULT 0)''')
    c.execute('''CREATE TABLE IF NOT EXISTS logs
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  timestamp TEXT,
                  account_name TEXT,
                  model TEXT,
                  status TEXT,
                  duration INTEGER)''')
    conn.commit()
    conn.close()

def get_db_conn():
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    return conn

# --- 3. è°ƒè¯•å‡½æ•° ---
async def debug_google_connection(name: str, cookies: dict, proxy_url: str = None):
    """è°ƒè¯• Google è¿æ¥é—®é¢˜ï¼Œè¿”å›è¯¦ç»†çš„è¯Šæ–­ä¿¡æ¯"""
    debug_info = {
        "ip_info": None,
        "gemini_response": None,
        "error": None
    }
    
    # 1. æ£€æŸ¥ä»£ç† IP å½’å±
    try:
        proxies = None
        if proxy_url:
            proxies = {
                "http": proxy_url,
                "https": proxy_url
            }
        
        ip_response = requests.get("http://ip-api.com/json", proxies=proxies, timeout=10)
        ip_info = ip_response.json()
        debug_info["ip_info"] = ip_info
        
        logger.info(f"ğŸ” è°ƒè¯• [{name}] - IP: {ip_info.get('query')} | åœ°åŒº: {ip_info.get('countryCode')} ({ip_info.get('country')})")
        
        if ip_info.get('countryCode') in ['CN', 'HK']:
            logger.warning(f"âš ï¸ è­¦å‘Š: é¦™æ¸¯/ä¸­å›½èŠ‚ç‚¹ææ˜“å¯¼è‡´ Google éªŒè¯å¤±è´¥ï¼")
    except Exception as e:
        logger.error(f"ğŸ” è°ƒè¯• [{name}] - ä»£ç†è¿æ¥å¤±è´¥: {e}")
        debug_info["error"] = f"ä»£ç†è¿æ¥å¤±è´¥: {e}"
        return debug_info
    
    # 2. å°è¯•è®¿é—® Gemini é¦–é¡µ
    try:
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
        }
        
        resp = requests.get(
            "https://gemini.google.com/app",
            cookies=cookies,
            headers=headers,
            proxies=proxies,
            timeout=20,
            allow_redirects=False
        )
        
        debug_info["gemini_response"] = {
            "status_code": resp.status_code,
            "headers": dict(resp.headers),
            "has_snlM0e": "SNlM0e" in resp.text,
            "content_length": len(resp.text)
        }
        
        logger.info(f"ğŸ” è°ƒè¯• [{name}] - Gemini å“åº”çŠ¶æ€: {resp.status_code}")
        
        if resp.status_code == 302:
            location = resp.headers.get('Location', 'æœªçŸ¥')
            logger.error(f"ğŸ” è°ƒè¯• [{name}] - è¢«é‡å®šå‘åˆ°: {location}")
            debug_info["error"] = f"Cookie å¤±æ•ˆï¼Œè¢«é‡å®šå‘åˆ°: {location}"
            
        elif resp.status_code == 200:
            if "SNlM0e" in resp.text:
                logger.success(f"ğŸ” è°ƒè¯• [{name}] - æ‰¾åˆ° SNlM0e Tokenï¼Œè¿æ¥æ­£å¸¸ï¼")
            else:
                # æå–é¡µé¢æ ‡é¢˜
                title = "æ— æ ‡é¢˜"
                if '<title>' in resp.text:
                    try:
                        title = resp.text.split('<title>')[1].split('</title>')[0]
                    except:
                        pass
                logger.warning(f"ğŸ” è°ƒè¯• [{name}] - çŠ¶æ€ç  200 ä½†æœªæ‰¾åˆ° Tokenï¼Œé¡µé¢æ ‡é¢˜: {title}")
                debug_info["error"] = f"æœªæ‰¾åˆ° SNlM0e Tokenï¼Œå¯èƒ½è¿”å›äº†éªŒè¯é¡µé¢: {title}"
        else:
            logger.error(f"ğŸ” è°ƒè¯• [{name}] - å¼‚å¸¸çŠ¶æ€ç : {resp.status_code}")
            debug_info["error"] = f"å¼‚å¸¸çŠ¶æ€ç : {resp.status_code}"
            
    except Exception as e:
        logger.error(f"ğŸ” è°ƒè¯• [{name}] - è¯·æ±‚é”™è¯¯: {e}")
        debug_info["error"] = f"è¯·æ±‚é”™è¯¯: {e}"
    
    return debug_info

# --- 4. è¾…åŠ©å‡½æ•°ï¼šæµå¼ç”Ÿæˆå™¨ ---
async def pseudo_stream_generator(text: str, model: str) -> AsyncGenerator[bytes, None]:
    chunk_id = f"chatcmpl-{int(time.time())}"
    created = int(time.time())
    
    step = 4 
    for i in range(0, len(text), step):
        chunk_text = text[i:i+step]
        data = {
            "id": chunk_id,
            "object": "chat.completion.chunk",
            "created": created,
            "model": model,
            "choices": [{"index": 0, "delta": {"content": chunk_text}, "finish_reason": None}]
        }
        yield f"data: {json.dumps(data)}\n\n".encode('utf-8')
        await asyncio.sleep(0.02)

    final_data = {
        "id": chunk_id,
        "object": "chat.completion.chunk",
        "created": created,
        "model": model,
        "choices": [{"index": 0, "delta": {}, "finish_reason": "stop"}]
    }
    yield f"data: {json.dumps(final_data)}\n\n".encode('utf-8')
    yield b"data: [DONE]\n\n"

# --- 4. æ ¸å¿ƒå¤„ç†é€»è¾‘ ---
async def process_gemini_request(request_data: dict, is_stream: bool):
    messages = request_data.get("messages", [])
    if not messages:
        raise ValueError("è¯·æ±‚ç¼ºå°‘messageså‚æ•°")
    
    model = request_data.get("model", "gemini-2.5-pro")
    if model not in ["gemini-2.5-pro", "gemini-2.5-flash", "gemini-pro"]:
        logger.warning(f"æœªçŸ¥æ¨¡å‹: {model}ï¼Œè‡ªåŠ¨å›é€€åˆ° gemini-2.5-pro")
        model = "gemini-2.5-pro"
    
    conn = get_db_conn()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM accounts WHERE is_active = 1")
    accounts = cursor.fetchall()
    
    if not accounts:
        conn.close()
        raise Exception("âŒ é”™è¯¯ï¼šæ²¡æœ‰å¯ç”¨çš„è´¦å·ï¼Œè¯·åœ¨é¢æ¿æ·»åŠ ï¼")

    account = random.choice(accounts)
    acc_id = account["id"]
    acc_name = account["name"]
    
    # ä¼˜å…ˆä» JSON è¯»å–å…¨é‡ Cookie
    all_cookies = {}
    if "cookie_json" in account.keys() and account["cookie_json"]:
        try:
            all_cookies = json.loads(account["cookie_json"])
        except:
            pass
    
    # å›é€€æœºåˆ¶
    if not all_cookies:
        all_cookies = {
            "__Secure-1PSID": account["cookie_1psid"],
            "__Secure-1PSIDTS": account["cookie_1psidts"]
        }
        if "cookie_1psidcc" in account.keys() and account["cookie_1psidcc"]:
             all_cookies["__Secure-1PSIDCC"] = account["cookie_1psidcc"]

    start_time = time.time()
    status = "ERROR"
    
    try:
        logger.info(f"ğŸ”„ è´¦å· [{acc_name}] æ­£åœ¨å¤„ç†è¯·æ±‚...")
        
        # åˆå§‹åŒ–å®¢æˆ·ç«¯
        client = GeminiClient(
            proxy=settings.PROXY_URL
        )
        
        # æ³¨å…¥å…¨é‡ Cookie (åŒ…å« 17 ä¸ª)
        client.cookies.update(all_cookies)
        
        # å¯åŠ¨åˆå§‹åŒ– (å¸¦è¶…æ—¶ä¿æŠ¤)
        await client.init(timeout=60, auto_close=True)
        
        full_prompt = ""
        for m in messages:
            if m['role'] == 'user':
                full_prompt += f"User: {m['content']}\n"
            elif m['role'] == 'assistant':
                full_prompt += f"Model: {m['content']}\n"
            elif m['role'] == 'system':
                full_prompt += f"System: {m['content']}\n"
        
        response = await client.generate_content(full_prompt, model=model)
        text = response.text
        
        status = "SUCCESS"
        cursor.execute("UPDATE accounts SET total_calls = total_calls + 1 WHERE id = ?", (acc_id,))
        conn.commit()
        
        if is_stream:
            return StreamingResponse(pseudo_stream_generator(text, model), media_type="text/event-stream")
        else:
            return JSONResponse({
                "id": f"chatcmpl-{int(time.time())}",
                "object": "chat.completion",
                "created": int(time.time()),
                "model": model,
                "choices": [{"index": 0, "message": {"role": "assistant", "content": text}, "finish_reason": "stop"}]
            })

    except Exception as e:
        logger.error(f"âŒ è´¦å· [{acc_name}] è°ƒç”¨å¤±è´¥: {e}")
        
        # ğŸ” å¦‚æœæ˜¯ Cookie ç›¸å…³é”™è¯¯ï¼Œæ‰§è¡Œè¯¦ç»†è°ƒè¯•
        if "Cookies invalid" in str(e) or "location" in str(e).lower():
            logger.warning(f"ğŸ” æ£€æµ‹åˆ° Cookie/IP é—®é¢˜ï¼Œå¯¹è´¦å· [{acc_name}] è¿›è¡Œè¯Šæ–­...")
            debug_cookies = {
                "__Secure-1PSID": cookie_1psid,
                "__Secure-1PSIDTS": cookie_1psidts
            }
            if cookie_1psidcc:
                debug_cookies["__Secure-1PSIDCC"] = cookie_1psidcc
                
            # æ³¨æ„ï¼šè¿™é‡Œæ˜¯åŒæ­¥è°ƒç”¨ï¼Œå› ä¸º debug_google_connection æ˜¯å¼‚æ­¥çš„
            # åœ¨ except å—ä¸­æˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ awaitï¼Œæ‰€ä»¥åˆ›å»ºä¸€ä¸ªåŒæ­¥ç‰ˆæœ¬
            try:
                loop = asyncio.get_event_loop()
                debug_result = loop.run_until_complete(debug_google_connection(acc_name, debug_cookies, settings.PROXY_URL))
                
                # è®°å½•è°ƒè¯•ç»“æœåˆ°æ—¥å¿—
                if debug_result["ip_info"]:
                    ip_info = debug_result["ip_info"]
                    logger.info(f"ğŸ” [{acc_name}] IP: {ip_info.get('query')} ({ip_info.get('countryCode', 'æœªçŸ¥')})")
                
                if debug_result["error"]:
                    logger.error(f"ğŸ” [{acc_name}] è¯Šæ–­ç»“æœ: {debug_result['error']}")
            except Exception as debug_err:
                logger.error(f"ğŸ” [{acc_name}] è¯Šæ–­å¤±è´¥: {debug_err}")
        
        if "Cookies invalid" in str(e):
             logger.critical(f"âš ï¸ è´¦å· [{acc_name}] Cookie å·²å¤±æ•ˆæˆ– IP è¢«æ‹’ï¼Œè¯·æ›´æ–°ï¼")
        raise e
    
    finally:
        duration = int((time.time() - start_time) * 1000)
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cursor.execute("INSERT INTO logs (timestamp, account_name, model, status, duration) VALUES (?, ?, ?, ?, ?)",
                       (timestamp, acc_name, model, status, duration))
        conn.commit()
        conn.close()

# --- 5. FastAPI åº”ç”¨åˆå§‹åŒ– ---

@asynccontextmanager
async def lifespan(app: FastAPI):
    init_db()
    url = f"http://127.0.0.1:{settings.PORT}"
    logger.success(f"ğŸš€ æœåŠ¡å¯åŠ¨æˆåŠŸï¼")
    logger.info(f"ğŸ‘‰ ç®¡ç†é¢æ¿: {url}")
    logger.info(f"ğŸ‘‰ API åœ°å€: {url}/v1/chat/completions")
    webbrowser.open(url)
    yield

app = FastAPI(lifespan=lifespan, title="Gemini Desktop API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

templates = Jinja2Templates(directory="templates")

# === è·¯ç”±éƒ¨åˆ† ===

@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request):
    conn = get_db_conn()
    accounts = conn.execute("SELECT * FROM accounts").fetchall()
    logs = conn.execute("SELECT * FROM logs ORDER BY id DESC LIMIT 20").fetchall()
    conn.close()
    return templates.TemplateResponse("dashboard.html", {
        "request": request, 
        "accounts": accounts, 
        "logs": logs, 
        "proxy": settings.PROXY_URL,
        "api_url": f"http://127.0.0.1:{settings.PORT}"
    })

@app.post("/account/add")
async def add_account(name: str = Form(...), p1: str = Form(...), p2: str = Form(...)):
    conn = get_db_conn()
    # æ‰‹åŠ¨æ·»åŠ åªå­˜åŸºç¡€çš„ï¼Œä¸æ¨è
    cookies_json = json.dumps({"__Secure-1PSID": p1, "__Secure-1PSIDTS": p2})
    conn.execute("INSERT INTO accounts (name, cookie_1psid, cookie_1psidts, cookie_json) VALUES (?, ?, ?, ?)", 
                 (name, p1, p2, cookies_json))
    conn.commit()
    conn.close()
    return RedirectResponse(url="/", status_code=303)

@app.get("/account/delete/{id}")
async def delete_account(id: int):
    conn = get_db_conn()
    conn.execute("DELETE FROM accounts WHERE id = ?", (id,))
    conn.commit()
    conn.close()
    return RedirectResponse(url="/", status_code=303)

@app.get("/account/toggle/{id}")
async def toggle_account(id: int):
    conn = get_db_conn()
    conn.execute("UPDATE accounts SET is_active = NOT is_active WHERE id = ?", (id,))
    conn.commit()
    conn.close()
    return RedirectResponse(url="/", status_code=303)

@app.get("/logs/clear")
async def clear_logs():
    conn = get_db_conn()
    conn.execute("DELETE FROM logs")
    conn.commit()
    conn.close()
    return RedirectResponse(url="/", status_code=303)

@app.post("/api/extract-cookies")
async def extract_cookies_from_har(request: Request):
    try:
        data = await request.json()
        raw_text = data.get("content", "")
        if not raw_text.strip():
            return JSONResponse(status_code=400, content={"success": False, "error": "å†…å®¹ä¸ºç©º"})
        
        success, session_data, logs = parse_and_validate(raw_text)
        
        if success and session_data:
            cookies = session_data.get("cookies", {})
            return JSONResponse({
                "success": True,
                "data": {"cookies": cookies},
                "logs": logs
            })
        else:
            return JSONResponse({"success": False, "error": "è§£æå¤±è´¥", "logs": logs})
    except Exception as e:
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post("/api/auto-add-account")
async def auto_add_account(request: Request):
    """è‡ªåŠ¨æ·»åŠ ä» HAR/è¯·æ±‚ä¸­æå–çš„è´¦å·ï¼ˆå¸¦è‡ªåŠ¨éªŒè¯åŠŸèƒ½ï¼‰"""
    try:
        data = await request.json()
        name = data.get("name", "è‡ªåŠ¨æå–è´¦å·")
        cookies = data.get("cookies", {})
        
        # 1. è·å–å¿…è¦çš„ Cookie
        cookie_1psid = cookies.get("__Secure-1PSID", "")
        cookie_1psidts = cookies.get("__Secure-1PSIDTS", "")
        cookie_1psidcc = cookies.get("__Secure-1PSIDCC", "")
        
        if not cookie_1psid or not cookie_1psidts:
            return JSONResponse({
                "success": False,
                "error": "ç¼ºå°‘å¿…è¦çš„ Cookie",
                "message": "éœ€è¦ __Secure-1PSID å’Œ __Secure-1PSIDTS"
            })

        # 2. ğŸ”ã€å…³é”®æ­¥éª¤ã€‘åœ¨å­˜å…¥æ•°æ®åº“å‰ï¼Œå…ˆè¿›è¡Œè¿é€šæ€§æµ‹è¯•
        logger.info(f"ğŸ§ª æ­£åœ¨éªŒè¯è´¦å· [{name}] çš„æœ‰æ•ˆæ€§...")
        
        try:
            # åˆå§‹åŒ–ä¸´æ—¶å®¢æˆ·ç«¯
            # ä¿®æ”¹ç‚¹ï¼šä½¿ç”¨ proxy å­—ç¬¦ä¸²å‚æ•°
            temp_client = GeminiClient(
                secure_1psid=cookie_1psid,
                secure_1psidts=cookie_1psidts,
                proxy=settings.PROXY_URL
            )
            
            # æ‰‹åŠ¨æ³¨å…¥ CC Cookie
            if cookie_1psidcc:
                temp_client.cookies["__Secure-1PSIDCC"] = cookie_1psidcc

            # âš¡ å°è¯•è¿æ¥ Google (è®¾ç½® 30 ç§’è¶…æ—¶)
            await temp_client.init(timeout=30, auto_close=True)
            logger.success(f"âœ… è´¦å· [{name}] éªŒè¯é€šè¿‡ï¼")
            
        except Exception as verify_err:
            error_str = str(verify_err)
            logger.error(f"âŒ è´¦å·éªŒè¯å¤±è´¥: {error_str}")
            
            # ğŸ” æ‰§è¡Œè¯¦ç»†è°ƒè¯•
            logger.info(f"ğŸ” å¼€å§‹å¯¹è´¦å· [{name}] è¿›è¡Œè¯¦ç»†è¯Šæ–­...")
            debug_cookies = {
                "__Secure-1PSID": cookie_1psid,
                "__Secure-1PSIDTS": cookie_1psidts
            }
            if cookie_1psidcc:
                debug_cookies["__Secure-1PSIDCC"] = cookie_1psidcc
                
            # ä½¿ç”¨ asyncio.run æ¥è¿è¡Œå¼‚æ­¥è°ƒè¯•å‡½æ•°
            try:
                debug_result = await debug_google_connection(name, debug_cookies, settings.PROXY_URL)
            except Exception as debug_err:
                logger.error(f"ğŸ” è¯Šæ–­è¿‡ç¨‹å‡ºé”™: {debug_err}")
                debug_result = {"error": f"è¯Šæ–­å¤±è´¥: {debug_err}"}
            
            # åˆ†æé”™è¯¯åŸå› ï¼Œè¿”å›ç»™å‰ç«¯
            tips = "æœªçŸ¥é”™è¯¯"
            if "Cookies invalid" in error_str:
                tips = "Cookie æ— æ•ˆã€‚è¯·ç¡®ä¿å¤åˆ¶äº† StreamGenerate è¯·æ±‚ï¼Œå¹¶ä¸”æ˜¯åœ¨æ— ç—•æ¨¡å¼ä¸‹æ“ä½œã€‚"
            elif "Timeout" in error_str or "ConnectError" in error_str:
                tips = "è¿æ¥ Google è¶…æ—¶ã€‚è¯·æ£€æŸ¥ä»£ç†æ˜¯å¦ç¨³å®š (æ¨èç¾å›½èŠ‚ç‚¹)ã€‚"
            elif "location" in error_str.lower():
                tips = "IP åœ°åŒºå¯èƒ½ä¸æ”¯æŒã€‚è¯·æ›´æ¢ç¾å›½/æ–°åŠ å¡èŠ‚ç‚¹ã€‚"
            
            # æ„å»ºè¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
            detailed_msg = f"ğŸš« æ— æ³•è¿æ¥ Googleï¼š{tips}\n\næŠ€æœ¯æŠ¥é”™: {error_str}\n\nğŸ” è¯Šæ–­ä¿¡æ¯:\n"
            
            if debug_result["ip_info"]:
                ip_info = debug_result["ip_info"]
                detailed_msg += f"â€¢ IP: {ip_info.get('query')} ({ip_info.get('countryCode', 'æœªçŸ¥')})\n"
            
            if debug_result["gemini_response"]:
                gemini_resp = debug_result["gemini_response"]
                detailed_msg += f"â€¢ Gemini å“åº”: {gemini_resp['status_code']}\n"
                if gemini_resp["status_code"] == 302:
                    detailed_msg += f"â€¢ é‡å®šå‘åˆ°: {gemini_resp['headers'].get('Location', 'æœªçŸ¥')}\n"
                elif gemini_resp["status_code"] == 200 and not gemini_resp["has_snlM0e"]:
                    detailed_msg += "â€¢ æœªæ‰¾åˆ° SNlM0e Token\n"
            
            if debug_result["error"]:
                detailed_msg += f"â€¢ é”™è¯¯: {debug_result['error']}\n"

            return JSONResponse({
                "success": False, 
                "error": "éªŒè¯å¤±è´¥", 
                "message": detailed_msg
            })

        # 3. éªŒè¯é€šè¿‡ï¼Œå­˜å…¥æ•°æ®åº“
        conn = get_db_conn()
        cursor = conn.cursor()
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing = cursor.execute(
            "SELECT id FROM accounts WHERE cookie_1psid = ?", 
            (cookie_1psid,)
        ).fetchone()
        
        if existing:
            conn.close()
            return JSONResponse({
                "success": False,
                "error": "è´¦å·å·²å­˜åœ¨",
                "message": "è¯¥ Cookie å¯¹åº”çš„è´¦å·å·²ç»æ·»åŠ è¿‡äº†"
            })
        
        # æ’å…¥æ–°è´¦å· (åŒ…å« 1PSIDCC)
        cursor.execute(
            "INSERT INTO accounts (name, cookie_1psid, cookie_1psidts, cookie_1psidcc) VALUES (?, ?, ?, ?)",
            (name, cookie_1psid, cookie_1psidts, cookie_1psidcc)
        )
        conn.commit()
        conn.close()
        
        return JSONResponse({
            "success": True,
            "message": f"ğŸ‰ è´¦å· '{name}' éªŒè¯é€šè¿‡å¹¶æ·»åŠ æˆåŠŸï¼",
            "account_id": cursor.lastrowid
        })
        
    except Exception as e:
        return JSONResponse(status_code=500, content={"success": False, "error": str(e)})

@app.post("/v1/chat/completions")
async def chat_api(request: Request):
    data = await request.json()
    is_stream = data.get("stream", False)
    try:
        return await process_gemini_request(data, is_stream)
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": {"message": str(e), "type": "internal_error"}})

@app.get("/v1/models")
async def models_api():
    current_time = int(time.time())
    return {
        "object": "list",
        "data": [{"id": "gemini-2.5-pro", "created": current_time, "object": "model", "owned_by": "google"}]
    }

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=settings.PORT, reload=False)

--- æ–‡ä»¶è·¯å¾„: requirements.txt ---

fastapi
uvicorn[standard]
pydantic-settings
python-dotenv
httpx
loguru
jinja2
gemini_webapi>=1.17.3
requests

--- æ–‡ä»¶è·¯å¾„: start.bat ---

@echo off
chcp 65001 >nul
title Gemini Desktop API Server
color 0A

echo ==========================================
echo       Gemini Desktop API Server
echo ==========================================
echo.

:: æ£€æŸ¥Python
py --version >nul 2>&1
if errorlevel 1 (
    echo [é”™è¯¯] æœªæ‰¾åˆ°Pythonï¼Œè¯·å…ˆå®‰è£…Python 3.8+
    pause
    exit /b 1
)

:: æ£€æŸ¥å¹¶å®‰è£…ä¾èµ–
echo [ä¿¡æ¯] æ£€æŸ¥ä¾èµ–...
py -m pip show fastapi >nul 2>&1
if errorlevel 1 (
    echo [ä¿¡æ¯] æ­£åœ¨å®‰è£…ä¾èµ–åŒ…...
    py -m pip install -r requirements.txt
    if errorlevel 1 (
        echo [é”™è¯¯] ä¾èµ–å®‰è£…å¤±è´¥
        pause
        exit /b 1
    )
)

:: ç¡®ä¿å®‰è£… requestsï¼ˆè°ƒè¯•åŠŸèƒ½éœ€è¦ï¼‰
py -m pip show requests >nul 2>&1
if errorlevel 1 (
    echo [ä¿¡æ¯] å®‰è£… requests æ¨¡å—ï¼ˆè°ƒè¯•åŠŸèƒ½éœ€è¦ï¼‰...
    py -m pip install requests
    if errorlevel 1 (
        echo [è­¦å‘Š] requests å®‰è£…å¤±è´¥ï¼Œè°ƒè¯•åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨
    )
)

:: æ£€æŸ¥é…ç½®æ–‡ä»¶
if not exist ".env" (
    echo [è­¦å‘Š] æœªæ‰¾åˆ°.envé…ç½®æ–‡ä»¶ï¼Œå°†ä».env.exampleå¤åˆ¶
    copy ".env.example" ".env" >nul 2>&1
    echo [æç¤º] è¯·ç¼–è¾‘.envæ–‡ä»¶å¹¶å¡«å…¥ä½ çš„Cookieä¿¡æ¯
)

echo.
echo [ä¿¡æ¯] æ­£åœ¨å¯åŠ¨æœåŠ¡å™¨...
echo [æç¤º] æœåŠ¡å™¨å¯åŠ¨åä¼šè‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨
echo [æç¤º] æŒ‰ Ctrl+C åœæ­¢æœåŠ¡å™¨
echo.

:: å¯åŠ¨æœåŠ¡å™¨
py main.py

if errorlevel 1 (
    echo.
    echo [é”™è¯¯] æœåŠ¡å™¨å¯åŠ¨å¤±è´¥
    pause
)

--- æ–‡ä»¶è·¯å¾„: test_debug.py ---

import asyncio
import sys
sys.path.append('.')

from main import debug_google_connection

async def test_debug():
    # æµ‹è¯•ç”¨çš„ Cookieï¼ˆè¯·æ›¿æ¢ä¸ºå®é™…çš„ï¼‰
    test_cookies = {
        "__Secure-1PSID": "test_value",
        "__Secure-1PSIDTS": "test_value",
    }
    
    proxy = "http://127.0.0.1:7890"
    
    print("å¼€å§‹æµ‹è¯•è°ƒè¯•åŠŸèƒ½...")
    result = await debug_google_connection("æµ‹è¯•è´¦å·", test_cookies, proxy)
    
    print("\n=== è¯Šæ–­ç»“æœ ===")
    print(f"IP ä¿¡æ¯: {result.get('ip_info')}")
    print(f"Gemini å“åº”: {result.get('gemini_response')}")
    print(f"é”™è¯¯: {result.get('error')}")

if __name__ == "__main__":
    asyncio.run(test_debug())

--- æ–‡ä»¶è·¯å¾„: templates\dashboard.html ---

<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini é€†å‘ API æ§åˆ¶å°</title>
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.3.1/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f0f2f5; padding: 20px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .card { border: none; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); margin-bottom: 20px; transition: transform 0.2s; }
        .card:hover { transform: translateY(-2px); }
        .api-box { background: #2d3436; color: #dfe6e9; padding: 15px; border-radius: 8px; font-family: monospace; font-size: 0.9rem; position: relative; }
        .copy-btn { position: absolute; right: 10px; top: 10px; font-size: 0.8rem; padding: 2px 8px; }
        .status-dot { height: 10px; width: 10px; background-color: #bbb; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-active { background-color: #00b894; box-shadow: 0 0 5px #00b894; }
        .status-inactive { background-color: #d63031; }
        .loading-spinner { display: inline-block; width: 1rem; height: 1rem; border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container" style="max-width: 1200px;">
        <header class="d-flex justify-content-between align-items-center mb-4">
            <div>
                <h2 class="fw-bold text-primary mb-0">ğŸ¤– Gemini é€†å‘ API æ§åˆ¶å°</h2>
                <small class="text-muted">æœ¬åœ°é«˜æ€§èƒ½ä»£ç†æœåŠ¡ â€¢ æ— éœ€ Docker</small>
            </div>
            <span class="badge bg-info text-dark">å½“å‰ä»£ç†: {{ proxy }}</span>
        </header>

        <div class="row">
            <div class="col-lg-4">
                
                <div class="card p-3 border-primary border-2">
                    <h5 class="card-title text-primary fw-bold mb-3">ğŸš€ API è¿æ¥é…ç½®</h5>
                    <p class="small text-muted mb-2">è¯·å°†ä»¥ä¸‹ä¿¡æ¯å¡«å…¥ NextChat / ChatBox ç­‰è½¯ä»¶ï¼š</p>
                    
                    <div class="mb-3">
                        <label class="small fw-bold text-muted">æ¥å£åœ°å€ (Base URL):</label>
                        <div class="api-box">
                            {{ api_url }}
                        </div>
                    </div>

                    <div class="mb-3">
                        <label class="small fw-bold text-muted">API Key (å¯†é’¥):</label>
                        <div class="api-box">
                            sk-any-key (ä»»æ„å¡«å†™)
                        </div>
                    </div>

                    <div class="mb-1">
                        <label class="small fw-bold text-muted">æ¨èæ¨¡å‹åç§°:</label>
                        <div class="d-flex gap-2 flex-wrap">
                            <span class="badge bg-secondary">gemini-2.5-pro</span>
                            <span class="badge bg-secondary">gemini-2.5-flash</span>
                            <span class="badge bg-secondary">gemini-pro</span>
                        </div>
                    </div>
                </div>

                <!-- è‡ªåŠ¨æå–åŠŸèƒ½ -->
                <div class="card p-3 mb-3">
                    <h5 class="card-title mb-3">ğŸ”® æ™ºèƒ½æå– Cookie</h5>
                    <p class="small text-muted mb-2">
                        <strong>æ”¯æŒæ ¼å¼ï¼š</strong>HARæ–‡ä»¶ã€ç½‘ç»œè¯·æ±‚å¤´ã€cURLå‘½ä»¤<br>
                        <strong>è·å–æ–¹æ³•ï¼š</strong>F12 â†’ Network â†’ æ‰¾åˆ° StreamGenerate â†’ å³é”® â†’ Copy â†’ Copy as HAR
                    </p>
                    
                    <div class="mb-2">
                        <label class="small text-muted">ç²˜è´´ HAR/è¯·æ±‚å†…å®¹ï¼š</label>
                        <textarea id="harContent" class="form-control" rows="4" placeholder="ç²˜è´´ HAR æ–‡ä»¶å†…å®¹æˆ–ç½‘ç»œè¯·æ±‚ä¿¡æ¯..."></textarea>
                    </div>
                    
                    <div class="d-grid gap-2">
                        <button type="button" class="btn btn-info" onclick="extractCookies()">
                            ğŸ“¡ è‡ªåŠ¨æå– Cookie
                        </button>
                    </div>
                    
                    <!-- æå–ç»“æœæ˜¾ç¤º -->
                    <div id="extractResult" class="mt-3" style="display: none;">
                        <div class="alert alert-info" role="alert">
                            <h6 class="alert-heading">ğŸ“Š æå–æ—¥å¿—</h6>
                            <pre id="extractLogs" class="mb-0 small" style="white-space: pre-wrap; max-height: 200px; overflow-y: auto;"></pre>
                        </div>
                        
                        <div id="extractedCookiesSection" style="display: none;">
                            <h6 class="small text-muted mb-2">æå–åˆ°çš„ Cookieï¼š</h6>
                            <div id="extractedCookiesList" class="small mb-2"></div>
                            
                            <div class="input-group mb-2">
                                <input type="text" id="extractedAccountName" class="form-control" placeholder="è´¦å·å¤‡æ³¨å">
                                <button class="btn btn-success" type="button" onclick="autoAddAccount()">
                                    â• æ·»åŠ åˆ°è´¦å·æ± 
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æ‰‹åŠ¨æ·»åŠ åŠŸèƒ½ -->
                <div class="card p-3">
                    <h5 class="card-title mb-3">â• æ‰‹åŠ¨æ·»åŠ  Gemini è´¦å·</h5>
                    <form action="/account/add" method="post">
                        <div class="mb-2">
                            <label class="small text-muted">å¤‡æ³¨å</label>
                            <input type="text" class="form-control" name="name" placeholder="ä¾‹å¦‚: è°·æ­Œä¸»å·" required>
                        </div>
                        <div class="mb-2">
                            <label class="small text-muted">Cookie: __Secure-1PSID</label>
                            <input type="text" class="form-control" name="p1" placeholder="ä»æµè§ˆå™¨ F12 è·å–" required>
                        </div>
                        <div class="mb-3">
                            <label class="small text-muted">Cookie: __Secure-1PSIDTS</label>
                            <input type="text" class="form-control" name="p2" placeholder="ä»æµè§ˆå™¨ F12 è·å–" required>
                        </div>
                        <button type="submit" class="btn btn-dark w-100">ç¡®è®¤æ·»åŠ </button>
                    </form>
                </div>
            </div>

            <div class="col-lg-8">
                
                <div class="card p-3">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="card-title m-0">ğŸ‘¥ è´¦å·è´Ÿè½½å‡è¡¡æ± </h5>
                        <span class="badge bg-light text-dark border">å…± {{ accounts|length }} ä¸ªè´¦å·</span>
                    </div>
                    
                    <div class="table-responsive">
                        <table class="table table-hover align-middle">
                            <thead class="table-light">
                                <tr>
                                    <th>çŠ¶æ€</th>
                                    <th>å¤‡æ³¨</th>
                                    <th>Cookieé¢„è§ˆ</th>
                                    <th>ç´¯è®¡è°ƒç”¨</th>
                                    <th>æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% if not accounts %}
                                <tr><td colspan="5" class="text-center text-muted py-4">æš‚æ— è´¦å·ï¼Œè¯·åœ¨å·¦ä¾§æ·»åŠ </td></tr>
                                {% endif %}
                                {% for acc in accounts %}
                                <tr>
                                    <td>
                                        {% if acc.is_active %}
                                        <span class="status-dot status-active"></span><span class="small text-success">å¯ç”¨</span>
                                        {% else %}
                                        <span class="status-dot status-inactive"></span><span class="small text-danger">ç¦ç”¨</span>
                                        {% endif %}
                                    </td>
                                    <td class="fw-bold">{{ acc.name }}</td>
                                    <td class="small text-muted" style="font-family: monospace;">{{ acc.cookie_1psid[:8] }}...</td>
                                    <td><span class="badge bg-primary rounded-pill">{{ acc.total_calls }}</span></td>
                                    <td>
                                        <a href="/account/toggle/{{ acc.id }}" class="btn btn-sm btn-outline-secondary py-0">åˆ‡æ¢</a>
                                        <a href="/account/delete/{{ acc.id }}" class="btn btn-sm btn-outline-danger py-0">åˆ é™¤</a>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="card p-3">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5 class="card-title m-0">ğŸ“Š å®æ—¶è°ƒç”¨æ—¥å¿—</h5>
                        <a href="/logs/clear" class="btn btn-sm btn-light border">æ¸…ç©ºæ—¥å¿—</a>
                    </div>
                    <div class="table-responsive">
                        <table class="table table-sm table-striped">
                            <thead><tr><th>æ—¶é—´</th><th>æ‰§è¡Œè´¦å·</th><th>æ¨¡å‹</th><th>è€—æ—¶</th><th>çŠ¶æ€</th></tr></thead>
                            <tbody>
                                {% if not logs %}
                                <tr><td colspan="5" class="text-center text-muted py-3">æš‚æ— è°ƒç”¨è®°å½•</td></tr>
                                {% endif %}
                                {% for log in logs %}
                                <tr>
                                    <td class="small">{{ log.timestamp.split(' ')[1] }}</td>
                                    <td class="small">{{ log.account_name }}</td>
                                    <td><span class="badge bg-secondary" style="font-size: 0.7rem">{{ log.model }}</span></td>
                                    <td class="small">{{ log.duration }}ms</td>
                                    <td>
                                        {% if log.status == 'SUCCESS' %}
                                        <span class="badge bg-success">æˆåŠŸ</span>
                                        {% else %}
                                        <span class="badge bg-danger">å¤±è´¥</span>
                                        {% endif %}
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>

            </div>
        </div>
    </div>

    <script>
        let extractedData = null;

        async function extractCookies() {
            const harContent = document.getElementById('harContent').value.trim();
            const resultDiv = document.getElementById('extractResult');
            const logsPre = document.getElementById('extractLogs');
            const cookiesSection = document.getElementById('extractedCookiesSection');
            const cookiesList = document.getElementById('extractedCookiesList');
            
            if (!harContent) {
                alert('è¯·ç²˜è´´ HAR æ–‡ä»¶å†…å®¹æˆ–ç½‘ç»œè¯·æ±‚ä¿¡æ¯');
                return;
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const extractBtn = event.target;
            const originalText = extractBtn.innerHTML;
            extractBtn.innerHTML = '<span class="loading-spinner"></span> æ­£åœ¨è§£æ...';
            extractBtn.disabled = true;

            try {
                const response = await fetch('/api/extract-cookies', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: harContent })
                });

                const result = await response.json();
                
                // æ˜¾ç¤ºç»“æœåŒºåŸŸ
                resultDiv.style.display = 'block';
                logsPre.textContent = result.logs || 'æ— æ—¥å¿—ä¿¡æ¯';

                if (result.success && result.data) {
                    extractedData = result.data;
                    
                    // æ˜¾ç¤ºæå–åˆ°çš„ Cookie
                    const cookies = result.data.cookies;
                    const missingCookies = result.data.missing_cookies || [];
                    
                    let cookiesHtml = '';
                    for (const [name, value] of Object.entries(cookies)) {
                        const isMissing = missingCookies.includes(name);
                        cookiesHtml += `
                            <div class="mb-1">
                                <span class="badge ${isMissing ? 'bg-warning' : 'bg-success'}">${name}</span>
                                <code class="ms-2">${value.substring(0, 30)}${value.length > 30 ? '...' : ''}</code>
                                ${isMissing ? '<small class="text-warning ms-2">(å¯èƒ½ç¼ºå¤±)</small>' : ''}
                            </div>
                        `;
                    }
                    
                    cookiesList.innerHTML = cookiesHtml || '<p class="text-muted">æœªæå–åˆ° Cookie</p>';
                    
                    // æ˜¾ç¤º Cookie åˆ—è¡¨å’Œæ·»åŠ æŒ‰é’®
                    cookiesSection.style.display = 'block';
                    
                    // è®¾ç½®é»˜è®¤è´¦å·å
                    const accountNameInput = document.getElementById('extractedAccountName');
                    if (!accountNameInput.value) {
                        accountNameInput.value = `è‡ªåŠ¨æå–_${new Date().toLocaleString()}`;
                    }
                } else {
                    extractedData = null;
                    cookiesSection.style.display = 'none';
                    
                    if (result.error) {
                        logsPre.textContent += '\n\nâŒ é”™è¯¯: ' + result.error;
                    }
                }
            } catch (error) {
                console.error('æå–å¤±è´¥:', error);
                resultDiv.style.display = 'block';
                logsPre.textContent = 'ç½‘ç»œè¯·æ±‚å¤±è´¥: ' + error.message;
                cookiesSection.style.display = 'none';
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                extractBtn.innerHTML = originalText;
                extractBtn.disabled = false;
            }
        }

        async function autoAddAccount() {
            if (!extractedData || !extractedData.cookies) {
                alert('è¯·å…ˆæå– Cookie');
                return;
            }

            const accountName = document.getElementById('extractedAccountName').value.trim();
            if (!accountName) {
                alert('è¯·è¾“å…¥è´¦å·å¤‡æ³¨å');
                return;
            }

            const addBtn = event.target;
            const originalText = addBtn.innerHTML;
            addBtn.innerHTML = '<span class="loading-spinner"></span> æ·»åŠ ä¸­...';
            addBtn.disabled = true;

            try {
                const response = await fetch('/api/auto-add-account', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: accountName,
                        cookies: extractedData.cookies
                    })
                });

                const result = await response.json();

                if (result.success) {
                    alert('è´¦å·æ·»åŠ æˆåŠŸï¼');
                    // åˆ·æ–°é¡µé¢ä»¥æ˜¾ç¤ºæ–°è´¦å·
                    window.location.reload();
                } else {
                    alert('æ·»åŠ å¤±è´¥: ' + (result.error || result.message || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('æ·»åŠ è´¦å·å¤±è´¥:', error);
                alert('ç½‘ç»œè¯·æ±‚å¤±è´¥: ' + error.message);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                addBtn.innerHTML = originalText;
                addBtn.disabled = false;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šåˆå§‹åŒ–ä»£ç 
        });
    </script>
</body>
</html>


